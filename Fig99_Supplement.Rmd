---
title: "Fig 99 Supplement"
author: "Douglas Fritz"
date: "2025-10-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("ggtree")

# install.packages("remotes")
# remotes::install_github(repo = "stan-dev/cmdstanr")

library(ape, quiet = T); library(phytools, quiet = T); library(stringr, quiet = T)
library(MetBrewer, quiet = T); library(parallel, quiet = T); library(mgcv, quiet = T)
library(cowplot, quiet = T); library(ggplot2, quiet = T); library(ggtree, quiet = T);
library(cmdstanr, quiet = T); library(binom, quiet = T); library(plotly) ; library(DescTools); 
library(readr, quiet = T); library(glue, quiet = T)
library(grid)
library(png)
library(vDiveR)
library(vcfR)
library(reticulate)
library(tidyverse)
library(foreach)
library(extrafont)
library(dsmisc)
library(phangorn)
library(glue)
library(readr)
library(svglite)
library(here)
library(svglite)
library(teal.modules.general)
library(treedataverse)

# font_import()
loadfonts(device="all") 





```



```{r global functions}
source(file = '2_Functions/2_1_Index_computation_20240909.R')


```



```{r load in}
## Not printed, set directory
here::i_am("PhylowaveDengue.Rproj")
st <- format(Sys.time(), "%Y-%m-%d_%H%M")

data_dir <- "4_Output_Data"
tree_st <- "2025-10-20_1143"
dataset_with_nodes_st <- tree_st

for (d in 1:4) {
  
  tree_file <- glue("{data_dir}/tree_DENV{d}_{tree_st}.rds")
  tree <- read_rds(tree_file)
  
  dataset_with_nodes_file <- glue("{data_dir}/dataset_with_nodes_index_DENV{d}_{dataset_with_nodes_st}.rds")
  dataset_with_nodes <- read_rds(dataset_with_nodes_file)
  
  gmat <- dist.nodes.with.names(tree)
  
  names_seqs <- tree$tip.label
  n_seq <- length(names_seqs)
  
  # Parse YEAR 
  times_seqs  <- suppressWarnings(as.numeric(stringr::word(names_seqs, 1, sep = stringr::fixed("_"))))
  
  # Root index: tips are 1..Ntip, so root is Ntip + 1 (ape convention)
  nroot <- length(tree$tip.label) + 1
  distance_to_root <- gmat[nroot, ]

  # Use a reference tip that exists in the distance vector names (robust if first entry isn't a tip)
  ref_tip <- intersect(names_seqs, names(distance_to_root))[1]

  root_height <- times_seqs[which(names_seqs == ref_tip)] - distance_to_root[ref_tip]

  # Internal nodes are indexed right after tips, sets height in time relative to tree root
  nodes_height <- root_height + distance_to_root[n_seq + (1:(n_seq - 1))] 
  
  
  colors_of_clades = met.brewer(name="Cross", n=length(levels(as.factor(dataset_with_nodes$clade_inferred))),
                            type="continuous")
  
  
  # First, generate the color key, based on the Nextstrain clade of each sequence.
  dataset_with_nodes$clade_color = as.factor(dataset_with_nodes$clade_inferred)
  clade_labels = levels(dataset_with_nodes$clade_color)
  levels(dataset_with_nodes$clade_color) = colors_of_clades
  dataset_with_nodes$clade_color = as.character(dataset_with_nodes$clade_color)
  dataset_with_nodes$clade_color[is.na(dataset_with_nodes$clade_color)] <- "grey"
  
  

  
  assign(glue("names_seqs_{d}"), names_seqs )
  assign(glue("n_seq_{d}"), length(names_seqs ))
  assign(glue("times_seqs_{d}"), times_seqs)
  assign(glue("nroot_{d}"), nroot)
  assign(glue("distance_to_root_{d}"), distance_to_root)
  assign(glue("root_height_{d}"), root_height)
  assign(glue("nodes_height_{d}"), nodes_height)
  assign(glue("genetic_distance_mat_{d}"), gmat)
  assign(glue("tree_DENV{d}"), tree)
  assign(glue("dataset_with_nodes_{d}"), dataset_with_nodes)
  assign(paste0("clade_labels_", d), clade_labels)
  assign(paste0("colors_clade_", d), colors_of_clades)
  assign(paste0("dataset_with_nodes_", d), dataset_with_nodes)
  
  
}
```



### Suplement Wind and Timescale robustness: Subplot comparison

```{r subplot comparison}

for (d in 1:4) {
  
# Retrieve relevant variables
  dataset_with_nodes <- get(glue('dataset_with_nodes_{d}'))
  time_distance_mat <-  get(glue("genetic_distance_mat_{d}"))
  timed_tree        <-  get(glue("tree_DENV{d}"))
  
# Define global plot parameters
  
## Length genome 
genome_length = 11000 # reference  https://nextstrain.org/dengue/all/genome Could also just use 11kb or something highly specific
## Mutation rate 
mutation_rate = 7.6e-4
  #7.6e-4 # mutation rate #ref https://pmc.ncbi.nlm.nih.gov/articles/PMC9030598/
mutation_rate_sci <- formatC(mutation_rate, format = "e", digits = 2)
# min_year <- round(min(dataset_with_nodes$time) - 1)

min_year <- 1965
max_year <- 2015
  
# Define wind values (x-axis )
wind_values <- seq(62, 730, length.out = 5) / 365  # Convert days to years

# Define timescale values (y-axis)
timescale_values <- seq(2, 20, length.out = 5)  # Years

par(mfrow = c(5, 5), oma = c(2, 2, 2, 2), mar = c(0.5, 0.5, 0.7, 0.5), mgp = c(2, 0.5, 0))  # Adjust margins

for (t in timescale_values) {
  for (w in wind_values) {
    # Update parameters
    timescale <- t
    wind <- w
    
    # Compute the index for the given wind and timescale
    
    dataset_with_nodes$index <- compute.index(
    time_distance_mat = time_distance_mat,
    timed_tree        = timed_tree,
    time_window       = wind,
    metadata          = dataset_with_nodes,
    mutation_rate     = mutation_rate,
    timescale         = timescale,
    genome_length     = genome_length 
  )
    
    # Plot the index
    plot(dataset_with_nodes$time, 
         dataset_with_nodes$index, 
         col = adjustcolor(dataset_with_nodes$clade_color, alpha.f = 1),
         bty = 'n', xlim = c(min_year, max_year), cex = 0.4,
         pch = 16, ylim = c(0, 1), 
         xaxt = 'n', yaxt = 'n',
         main = paste0("TS: ", timescale, " | W: ", round(wind, 2))
    )
    # Add axes for the leftmost and bottom subplots only
    if (w == wind_values[1]) axis(2, las = 2, lwd = 0.5)  # Left y-axis
    if (t == timescale_values[5]) axis(1, lwd = 0.5)      # Bottom x-axis
  }
}

mtext("Window (years)", side = 1, outer = TRUE, line = 1.2, cex = 0.6)
mtext("Timescale (years)", side = 2, outer = TRUE, line = 1.2, cex= 0.6)
mtext(paste0(
  "Index Plots for Various Timescales and Windows",
  "Genome Length: ", genome_length,
  "Mutation Rate: ", mutation_rate_sci), side = 3, outer = TRUE, line = 1, cex = 0.6, font = 1)
  

# After generating the 5x5 subplot grid
file_name_subplot <- glue("3_Output_Figures/3_5_DENV/3_5_99_Supplement/index_plots_DENV{d}_{mutation_rate_sci}_TS{min(timescale_values)}-{max(timescale_values)}_W{round(min(wind_values),2)}-{round(max(wind_values),2)}.pdf")

# Save the current plot to a PDF
dev.copy(pdf, file = file_name_subplot, width = 10, height = 10)  # Adjust dimensions as needed
dev.off()  # Close the PDF device

}

```

#Plotting model splines on index

```{r loading splits}

data_dir <- "4_Output_Data"
split_st <- "2025-10-30_1426"

for (d in 1:4) {
  
  split_merged_file <- glue("{data_dir}/merged_splits_DENV{d}_{split_st}.rds")
  split_unmerged_file <- glue("{data_dir}/unmerged_splits_DENV{d}_{split_st}.rds")
  potential_splits_file <- glue("{data_dir}/Max_groups_potential_splits_reasonable_DENV{d}_timescale7_wind1_2025-10-20_1143.rds")
  
  split_merged <- read_rds(split_merged_file)
  split_unmerged <- read_rds(split_unmerged_file)
  potential_splits <- read_rds(potential_splits_file)
  
  
  assign(glue("split_merged_{d}"), split_merged)
  assign(glue("split_unmerged_{d}"), split_unmerged)
  assign(glue("potential_splits_{d}"), potential_splits)
  
  
}


# Check params stored with potential splits to check provenance 
attr(split_merged_1, "params", exact = TRUE)
attr(split_merged_2, "params", exact = TRUE)
attr(split_merged_3, "params", exact = TRUE)
attr(split_merged_4, "params", exact = TRUE)

attr(split_unmerged_1, "params", exact = TRUE)
attr(split_unmerged_2, "params", exact = TRUE)
attr(split_unmerged_3, "params", exact = TRUE)
attr(split_unmerged_4, "params", exact = TRUE)

# Check params stored with potential splits to check provenance 
attr(potential_splits_1, "params", exact = TRUE)
attr(potential_splits_2, "params", exact = TRUE)
attr(potential_splits_3, "params", exact = TRUE)
attr(potential_splits_4, "params", exact = TRUE)



```



```{r Plot index w splines}
## Find group colours

library(ggforce)


spline_on_index_plot <- function(
    dengue = 1:4, 
    st = format(Sys.time(), tz = "UTC", "%Y-%m-%d_%H%M"),
    potential_split_name = "potential_splits_%d",
    output_dir = "3_Output_Figures/3_5_DENV/3_5_99_Supplement",
    filename = "DENV%d_spline_on_index.svg", 
    width = 8, 
    height = 5,
    palette_name = "Cross",
    log_y = TRUE,                 
    facet_ncol = 3,               # grid width
    paginate = FALSE,             # TRUE = multi-page PDF via ggforce
    pdf_per_page_cols = 3,        # used when paginate = TRUE
    pdf_per_page_rows = 4 )
{
  
  for (d in dengue) {
    ## Dynamically retrieve the relevant variables
    dataset_with_nodes <- get(paste0('dataset_with_nodes_', d))
    potential_splits <- get(sprintf(potential_split_name, d))
    
    
    k <- length(potential_splits$best_mod)
    fits <- lapply(seq_len(k), function(j) {
      fv <- predict(potential_splits$best_mod[[j]])
      if (isTRUE(log_y)) exp(fv) else fv
    })
    grps <- lapply(seq_len(k), function(j) as.factor(potential_splits$best_groups[[j]]))
    
    # Build a long data frame: one block per step
    df_long <-bind_rows(lapply(seq_len(k), function(j) {
      g  <- grps[[j]]
      ng <- nlevels(g)
      pal <- MetBrewer::met.brewer("Cross", ng, type = "continuous")
      col <- pal[as.integer(g)]
      dplyr::mutate(
        dataset_with_nodes,
        model_step = j,
        grp_step   = g,
        col_step   = col,
        fitted     = fits[[j]]
      )
    }))
    
    p_base <- ggplot2::ggplot(df_long, ggplot2::aes(time, index)) +
      ggplot2::geom_point(ggplot2::aes(colour = col_step), alpha = 0.7, size = 0.6, show.legend = FALSE) +
      ggplot2::geom_line(ggplot2::aes(y = fitted, group = grp_step, colour = col_step),
                         linewidth = 0.5, show.legend = FALSE) +
      ggplot2::scale_colour_identity() +
      ggplot2::labs(
        title = sprintf("DENV%d — observed vs fitted across steps", d),
        x = "Time", y = "Index"
      ) +
      ggplot2::theme_minimal(base_size = 9)
    
    
    if (isTRUE(paginate)) {
      # Multi-page PDF using ggforce pagination
      pdf_path <- file.path(output_dir, sprintf("DENV%d_steps_faceted_%s.pdf", d, st))
      ncol <- pdf_per_page_cols
      nrow <- pdf_per_page_rows
      w <- ncol * 3.2
      h <- nrow * 2.6
      
      # figure out how many pages
      np <- ggforce::n_pages(
        p_base + ggforce::facet_wrap_paginate(~ model_step, ncol = ncol, nrow = nrow, page = 1)
      )
      
      grDevices::pdf(pdf_path, width = w, height = h, onefile = TRUE)
      on.exit(grDevices::dev.off(), add = TRUE)
      for (pg in seq_len(np)) {
        print(p_base + ggforce::facet_wrap_paginate(~ model_step, ncol = ncol, nrow = nrow, page = pg))
      }
      message("Wrote: ", pdf_path)
      
    } else {
      # One giant SVG with all facets 
      facet_nrow <- ceiling(k / facet_ncol) 
      p_all <- p_base + ggplot2::facet_wrap(~ model_step, ncol = facet_ncol)
      
      svg_path <- file.path(output_dir, sprintf(filename, d, st))
      svglite::svglite(svg_path, width = facet_ncol * 3.2, height = facet_nrow * 2.6)
      on.exit(grDevices::dev.off(), add = TRUE)
      print(p_all)
      message("Wrote: ", svg_path)
    }
  }
}


spline_on_index_plot(
    dengue = 1:4, 
    st = format(Sys.time(), tz = "UTC", "%Y-%m-%d_%H%M"),
    potential_split_name = "potential_splits_%d",
    output_dir = "3_Output_Figures/3_5_DENV/3_5_99_Supplement",
    filename = "DENV%d_spline_on_index_%s.svg", 
    width = 8, 
    height = 5,
    palette_name = "Cross",
    log_y = TRUE,                 
    facet_ncol = 3,               # grid width
    paginate = FALSE,             # TRUE = multi-page PDF via ggforce FALSE = 1 big SVG
    pdf_per_page_cols = 3,        # used when paginate = TRUE
    pdf_per_page_rows = 4 )


```

